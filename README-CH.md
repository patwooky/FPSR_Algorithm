# 🎲 FPS-R: Frame-Persistent Stateless Randomization 静态律动算法

## 目录

- [FPS-R 是什么 ?](#fps-r-是什么-)
  - [FPS-R 简介](#fps-r-简介)
  - [运动哲学](#运动哲学)
- [核心特性](#核心特性)
- [动画中的示例用法](#动画中的示例用法)
- [为什么我们需要新的随机流生成器？](#为什么我们需要新的随机流生成器)
  - [“持续性随机性”的本质](#持续性随机性的本质)
  - [传统方法的局限性](#传统方法的局限性)
  - [FPS-R 的独特之处](#fps-r-的独特之处)
- [FPS-R 的不同模式](#fps-r-的不同模式)
  - [叠模机制](#叠模机制)
  - [量跃机制](#量跃机制)
- [应用场景](#应用场景)
- [工作原理](#工作原理)

---

## FPS-R 是什么 ?

#### _拥有结构灵魂的无状态不可预测性_
### FPS-R 简介

### 引言

**FPS-R** 是 `Frame-Persistent Stateless Randomisation`（中文可译为 `静态律动算法`）的缩写。它是一种轻量级的算法模式，用于模拟具有持续感却无记忆依赖的随机性，沿着连续的时间轴运行。非常适合用于程序化动画、故障艺术美学、合成的有机行为模拟，以及模拟类比噪声与伪影。

FPS-R 的灵感来自自然行为，如眼动扫视、动物觅食、人类犹豫、捕猎潜行以及结构化噪声等。它不依赖前一帧的记忆，依然能展现出出乎意料的变化。你可以将其想象为探险者手电筒在黑暗洞穴中的节奏——暂停、颤动、有目的地漂移；又或是一名士兵手中步枪清扫房间的动作——移动与停留，每一次停顿都与之前的状态毫不相关。  
> _**FPS-R 是一个操控时间中数值变化的雕刻家，塑造出具有节奏感的行为轨迹**_

当 FPS-R 的驱动轴从时间变为空间，它便化身为形状的雕塑者、天际线的建构者。它“跳-持”逻辑在空间中演变为图案排列，它的节奏变成了浮雕纹理。  
> _**FPS-R 不只是一个运动语言——它是一种几何方言。**_

它具有 **可重复性**、**可调节性**，并且是 **帧依赖的**，使其成为各类基于时间的内容创作平台（如 Houdini、Maya、3D Studio Max、Nuke、Adobe After Effects），GLSL、P5.js、游戏引擎（Unity、Unreal）以及嵌入式环境中十分通用的工具。  
由于其结构简洁且高效，FPS-R 也可以轻松移植到任何支持表达式或脚本的三维平台上。

在空间域中，FPS-R 可用于着色器中的顶点位移或表面扰动，其效果可通过法线、凹凸、视差等技术表达出来。  
当它被整合进程序化建模流程时，FPS-R 成为一个能够生成丰富细节与递归层次结构的几何生成器——非常适合用于杂项构件（greebling）、侵蚀图、风格化地形以及科幻面板纹理等场景。  
虽然 FPS-R 天生不具备重复性，但通过合理的平铺技术，它依然可以在 UV 空间中实现图案的无缝拼接，或者自然地包裹在曲面结构上，实现**在不受限制的前提下给予最大掌控力**。

### 原则与哲思
---
### 🧭 指导理念  
“FPS-R 不是一个具体的算法，而是一种用于**塑造信号**的设计哲学。  
无论是通过算术折叠还是信号量化——无论是在时间域还是空间域——它的核心目标始终如一：赋予结构以行为的自由。”

---

### 🎭 运动哲学  
**FPS-R 模拟了犹豫的不确定性——但在相同的框架下，它同样能够表达本能反应。**  
当它的时间保持较短时，表现为*冲动*：快速、跳跃、精警的反应。  
而当保持时间延长，就体现为*犹豫*：深思的停顿、迟缓的状态、带有思考错觉的行为。  

它并不是在模式之间切换——它是在**雕刻时间**。  
数值本身可能是随机的，但它们*何时*出现却由帧数本身决定——创造出一种即使在没有记忆的条件下，也显得有节奏、有意图的动态感知。  
所呈现的不是混乱，而是**被结构引导的时间行为**。

> 🧠 教学注释：“No-sim is the best sim.”（无模拟胜有模拟）  
> 在教授 Houdini（一个以仿真著称的软件）时，我常常提醒学生：  
> 搭建一个不依赖帧间状态传递的程序系统，往往比依赖复杂模拟更优雅。  
> 最精妙的系统，是那些每一帧都独立存在，却仿佛拥有记忆的结构。

---
## 🗣 一种新的语法："间歇式突动静止" — 一种基于节奏的程序行为语法

FPS-R 带来的不仅是一组全新的算法，更是一个用于描述运动行为的*语言词汇体系*。  
它生成的不是滤波器，也不是曲线——而是一种**构成性结构**：  
**跳跃 → 停留 → 重新取样 → 循环**  
我们称这种行为为 **“随机移动-停留（Randomised Move-and-Hold）”**。

它捕捉到了颤动、犹豫、  
以及那些仿佛在思考的停顿。


---
### ✨ 核心特性

- 基于帧的 **可重复性**，无需存储状态  
- 可调节的 **混沌特征曲线**，支持模块化曲线塑形  
- 兼容无状态着色器、模拟循环以及实时系统  
- 理想于生成具有“生命感”而非算法感的行为模式

---
### 🎞 动画中的示例用法

![单只眼球直视前方，伴随 FPS-R 式扫视行为](resources/readme/images/h_fpsr_01_v002_02.gif)  
*在 Houdini 中的模拟——单只眼球直视前方，伴随 FPS-R 式扫视行为*

![双眼注视移动方块，叠加 FPS-R 扫视层级](resources/readme/images/h_fpsr_01_v002.gif)  
*在 Houdini 中的模拟——双眼注视移动方块，于目标追踪之上叠加 FPS-R 扫视行为*


---

## 🤔 面对无序的世界，我们为何还需另一种秩序之术？

### 🧬 “持续性随机性”的本质

在自然与人工系统中，随机性很少表现为纯粹的噪声——它通常会保留、持续，或以一种看似有意图的方式演变。无论是斑驳光影的闪烁、模拟机器的抖动，还是眼睛扫视时轻微的跳跃，我们经常遇到保形或渐变的随机行为。尽管这种现象极为常见，大多数内容创作工具却难以以直观、轻量的方式模拟、表现或复现它。要重建这种有结构的不可预测性，往往需要耗时的自定义编码或不直观的工作流程。

> ✒️ 隐喻札记：*FPS-R 就像邮局里的公共签字笔。*  
> 人们来来往往：有人拿起它，有人随手放歪，有时几个小时没人碰它。  
> 每一次互动都会改变它的朝向、位置或状态——却从不携带记忆。  
> 然而，在快转的监控录像中，它仿佛在有意识地起舞。

### 🧱 传统方法的局限性

现有的主流技术通常分为两类：

- **Worley 类噪声函数**：这类算法通常依赖于在空间中散布的特征点（常通过抖动网格或基于哈希的方式生成），并对每个采样点与周围特征点之间的距离进行计算。尽管 Worley 噪声在生成类细胞纹理方面非常有效，但其典型实现中，特征点通常分布均匀，导致 Voronoi 结构的单元尺寸与亮度较为一致。这使得位移映射中各区域的振幅趋于相同，缺乏更具随机性或有机性的变化表现。此外，Worley 噪声的计算步骤较多——包括查表、距离计算、排序等操作，尤其是在使用高阶 Fn 组合、输入扭曲（warping）、或多层 octave 混合时，复杂度和计算开销都会显著增加，也使得其在可视化和直觉控制方面不如一些更为简洁的无状态方法。

- **依赖前帧状态的逻辑**：这种方法通过帧间状态传递来模拟“持有”随机值。然而，它引入了更高的复杂性，并强烈依赖平台对帧间数据共享的支持（如 Houdini）。此外，它通常无法在表达式字段或着色器片段这类轻量环境中实现，从而限制了其可移植性。

### ⚙️ FPS-R 的独特之处

FPS-R（Frame-Persistent Stateless Randomization, 帧持久性无状态随机算法）为这个长期存在的问题提供了一种轻量而高可移植性的解决方案。其核心方法是 **叠模机制（Stacked Modulo, SM）**，通过分层模运算与偏移累加，生成在帧间演化的结构化随机值，**无需状态记录或查表操作**。

主要优势包括：

- ✅ **真正无状态**：FPS-R 完全不依赖前帧数据或任何持久内存缓冲。
- 🧠 **简洁可读**：在 Houdini 表达式中使用 `$F` 或 VEX 中使用 `@Frame`，即可一行实现。
- 🛠️ **平台无关**：在任何支持帧信息的环境中都能无障碍运行，即便不支持高级记忆机制。
- ⚡ **性能友好**：不涉及复杂距离函数、哈希查表或散点生成，非常适合多重叠加、实时或高性能场景。

---
## 🧬 FPS-R 的不同模式

### 🌀 Stacked Modulo（叠模机制）

这是 FPS-R 的原始模式。**叠模机制**通过层叠的模运算和偏移量累加，生成输出值及其“持有帧长”的连贯且不可预测的变化。这种方式极具表现力，能够模拟信号漂移或有机不规则现象。

- 给人以 *“没有记忆的记忆感”*  
- 通过频率、幅度与相位控制进行塑形  
- 轻量，且易于组合嵌套

**叠模机制特点：**

- 可调节的随机值“持有”时长上限  
- 使用平台原生的 `rand()` 或等效随机函数以保持熵  
- 支持高度精简的一行实现，只需满足以下条件：
  - 提供一个随机函数（例如 `rand()`）
  - 提供一个模运算函数（例如 `mod()` 或 `%`）
  - 能获取当前帧号作为整数输入


---

### ✴ Quantised Switching（量跃机制）

**量跃机制**通过确定性伪随机索引，从用户定义的输入中选择离散数值。它非常适合用于触发状态切换、离散闪烁事件或级联逻辑。

该模式具有广泛的灵活性与配置空间：
- 非常适合用于 **故障跳变**、**通道闪烁** 或 **逻辑状态切换**  
- 虽然无状态，但帧间始终保持连贯  
- 支持频率塑形与取值分布控制

**量跃机制特点：**
- 可接受任意输入类型：程序性噪声、参数曲线或查找样条  
- 可选的量化旁路，可输出连续、有序的结果  
- 可选的随机旁路，支持使用原始输入进行完全结构化的状态切换

这两种模式是可互操作的——通过叠加使用，可以将突变的“跳跃”与平滑的“漂移”结合在一起，生成更丰富的行为特征。


---

## 🧪 应用场景

- **程序性动画系统**：用于生成具有结构性的运动，避免机械式重复  
- **模拟伪影仿真**：如色彩偏移、信号跳跃与模拟抖动等模拟美学效果  
- **嵌入式系统与微控制平台**：在内存有限但需要时间变化的场景中表现尤为高效  
- **注意力转移建模**：可用于模拟生物体的凝视、转移、犹豫或锁定行为，具有心理动机的拟真感  
- **人群系统驱动**：用于状态迁移或群体响应，产生局部随机性而不失群体协调（如逃散、涌入等）  
- **游戏与 XR 场景行为生成**：适用于低性能设备上的随机动画、敌人巡视路径、物理反馈或环境扰动  
- **无模拟环境中的行为构建**：无需建立全局状态机或缓存系统，即可生成复杂、动态且“活着”的逻辑响应行为


---

## 🔩 工作原理

FPS-R 利用以帧为索引的逻辑 —— 通常包括叠模运算、节奏拉伸曲线与确定性伪随机方法 —— 在无需内部状态的前提下生成熵值。  
它输出的运动与行为在“无记忆”状态下依然能够演化得可信且自然。
