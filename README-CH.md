# 🎲 FPS-R: Frame-Persistent Stateless Randomization 静态律动算法

## 目录

- [FPS-R 是什么 ?](#fps-r-是什么-)
  - [FPS-R 简介](#fps-r-简介)
  - [运动哲学](#运动哲学)
- [核心特性](#核心特性)
- [动画中的示例用法](#动画中的示例用法)
- [为什么我们需要新的随机流生成器？](#为什么我们需要新的随机流生成器)
  - [“持续性随机性”的本质](#持续性随机性的本质)
  - [传统方法的局限性](#传统方法的局限性)
  - [FPS-R 的独特之处](#fps-r-的独特之处)
- [FPS-R 的不同模式](#fps-r-的不同模式)
  - [叠模机制](#叠模机制)
  - [量跃机制](#量跃机制)
- [应用场景](#应用场景)
- [工作原理](#工作原理)

---

## FPS-R 是什么 ?

#### _拥有结构灵魂的无状态不可预测性_
### FPS-R 简介

**FPS-R** 是 “Frame-Persistent Stateless Randomisation”（静态律动算法） 的缩写。它是一种轻量级的算法模式，用于在连续时间轴上模拟 *持久但无状态的随机性*，非常适合程序化运动、故障美学、合成有机行为及类比伪影的表现。

其灵感源自自然中的行为模式，例如眼动扫视、动物觅食、人类犹豫、捕食者潜行以及结构性噪声。FPS-R 能在不依赖上一帧记忆的前提下，生成具有节奏感的不可预测性。  
它就像探险者在漆黑洞穴中挥舞的手电筒——时而停顿、时而抖动、时而有意偏移；又如士兵在执行扫楼任务时步枪的移动轨迹：在战略点之间前进和停驻，每次落点与先前毫无关联，却仿佛早有布局

### 🎭 运动哲学
**FPSR 模拟的是“犹豫”的不可预测性，但它同样能够表现本能。**  
当帧的持续时间很短时，它展现的是一种“冲动”：短促而凌厉，如惊跳般迅速。  
而当帧被延长时，它则传递出“犹豫感”：保留、停顿、像是在思考接下来会发生什么。  
二者都来自同一个算法——FPSR 并没有切换模式，而是在**雕刻时间本身**。  
其中的数值虽然随机生成，但它们何时出现，其实是由帧编号驱动的节奏所决定。  
由此构成的，不是混乱，而是一种**被结构引导的时间行为**。

> 🧠 教学札记：「No-sim is the best sim.」  
> 在 Houdini 的教学中，我常告诉学生：若能设计出**无需帧间依赖**的程序系统，那就优于使用复杂模拟的解法。  
> 真正优雅的方案，是让每一帧都能独立生长，却又仿佛记得过去。


---
### ✨ 核心特性

- 基于帧的锚定重复性，无需存储状态  
- 可调混沌曲线轮廓，支持模块化塑形  
- 兼容无状态的着色器、模拟循环与实时系统  
- 理想用于生成**有生命感**而非程式化的行为

---
### 🎞 动画中的示例用法

![单只眼球直视前方，伴随 FPS-R 式扫视行为](resources/readme/images/h_fpsr_01_v002_02.gif)  
*在 Houdini 中的模拟——单只眼球直视前方，伴随 FPS-R 式扫视行为*

![双眼注视移动方块，叠加 FPS-R 扫视层级](resources/readme/images/h_fpsr_01_v002.gif)  
*在 Houdini 中的模拟——双眼注视移动方块，于目标追踪之上叠加 FPS-R 扫视行为*


---

### 💡 为什么我们需要新的随机流生成器？

### 🧬 “持续性随机性”的本质

在自然与人工系统中，随机性很少表现为纯粹的噪声——它通常会保留、持续，或以一种看似有意图的方式演变。无论是斑驳光影的闪烁、模拟机器的抖动，还是眼睛扫视时轻微的跳跃，我们经常遇到保形或渐变的随机行为。尽管这种现象极为常见，大多数内容创作工具却难以以直观、轻量的方式模拟、表现或复现它。要重建这种有结构的不可预测性，往往需要耗时的自定义编码或不直观的工作流程。

> ✒️ 隐喻札记：*FPS-R 就像邮局里的公共签字笔。*  
> 人们来来往往：有人拿起它，有人随手放歪，有时几个小时没人碰它。  
> 每一次互动都会改变它的朝向、位置或状态——却从不携带记忆。  
> 然而，在快转的监控录像中，它仿佛在有意识地起舞。

### 🧱 传统方法的局限性

现有的主流技术通常分为两类：

- **Worley 类噪声函数**：这类算法通常依赖于在空间中散布的特征点（常通过抖动网格或基于哈希的方式生成），并对每个采样点与周围特征点之间的距离进行计算。尽管 Worley 噪声在生成类细胞纹理方面非常有效，但其典型实现中，特征点通常分布均匀，导致 Voronoi 结构的单元尺寸与亮度较为一致。这使得位移映射中各区域的振幅趋于相同，缺乏更具随机性或有机性的变化表现。此外，Worley 噪声的计算步骤较多——包括查表、距离计算、排序等操作，尤其是在使用高阶 Fn 组合、输入扭曲（warping）、或多层 octave 混合时，复杂度和计算开销都会显著增加，也使得其在可视化和直觉控制方面不如一些更为简洁的无状态方法。

- **依赖前帧状态的逻辑**：这种方法通过帧间状态传递来模拟“持有”随机值。然而，它引入了更高的复杂性，并强烈依赖平台对帧间数据共享的支持（如 Houdini）。此外，它通常无法在表达式字段或着色器片段这类轻量环境中实现，从而限制了其可移植性。

### ⚙️ FPS-R 的独特之处

FPS-R（Frame-Persistent Stateless Randomization, 帧持久性无状态随机算法）为这个长期存在的问题提供了一种轻量而高可移植性的解决方案。其核心方法是 **叠模机制（Stacked Modulo, SM）**，通过分层模运算与偏移累加，生成在帧间演化的结构化随机值，**无需状态记录或查表操作**。

主要优势包括：

- ✅ **真正无状态**：FPS-R 完全不依赖前帧数据或任何持久内存缓冲。
- 🧠 **简洁可读**：在 Houdini 表达式中使用 `$F` 或 VEX 中使用 `@Frame`，即可一行实现。
- 🛠️ **平台无关**：在任何支持帧信息的环境中都能无障碍运行，即便不支持高级记忆机制。
- ⚡ **性能友好**：不涉及复杂距离函数、哈希查表或散点生成，非常适合多重叠加、实时或高性能场景。

---
## 🧬 FPS-R 的不同模式

### 🌀 Stacked Modulo（叠模机制）

这是 FPS-R 的原始模式。**叠模机制**通过层叠的模运算和偏移量累加，生成输出值及其“持有帧长”的连贯且不可预测的变化。这种方式极具表现力，能够模拟信号漂移或有机不规则现象。

- 给人以 *“没有记忆的记忆感”*  
- 通过频率、幅度与相位控制进行塑形  
- 轻量，且易于组合嵌套

**叠模机制特点：**

- 可调节的随机值“持有”时长上限  
- 使用平台原生的 `rand()` 或等效随机函数以保持熵  
- 支持高度精简的一行实现，只需满足以下条件：
  - 提供一个随机函数（例如 `rand()`）
  - 提供一个模运算函数（例如 `mod()` 或 `%`）
  - 能获取当前帧号作为整数输入


---

### ✴ Quantised Switching（量跃机制）

**量跃机制**通过确定性伪随机索引，从用户定义的输入中选择离散数值。它非常适合用于触发状态切换、离散闪烁事件或级联逻辑。

该模式具有广泛的灵活性与配置空间：
- 非常适合用于 **故障跳变**、**通道闪烁** 或 **逻辑状态切换**  
- 虽然无状态，但帧间始终保持连贯  
- 支持频率塑形与取值分布控制

**量跃机制特点：**
- 可接受任意输入类型：程序性噪声、参数曲线或查找样条  
- 可选的量化旁路，可输出连续、有序的结果  
- 可选的随机旁路，支持使用原始输入进行完全结构化的状态切换

这两种模式是可互操作的——通过叠加使用，可以将突变的“跳跃”与平滑的“漂移”结合在一起，生成更丰富的行为特征。


---

## 🧪 应用场景

- **程序性动画系统**：用于生成具有结构性的运动，避免机械式重复  
- **模拟伪影仿真**：如色彩偏移、信号跳跃与模拟抖动等模拟美学效果  
- **嵌入式系统与微控制平台**：在内存有限但需要时间变化的场景中表现尤为高效  
- **注意力转移建模**：可用于模拟生物体的凝视、转移、犹豫或锁定行为，具有心理动机的拟真感  
- **人群系统驱动**：用于状态迁移或群体响应，产生局部随机性而不失群体协调（如逃散、涌入等）  
- **游戏与 XR 场景行为生成**：适用于低性能设备上的随机动画、敌人巡视路径、物理反馈或环境扰动  
- **无模拟环境中的行为构建**：无需建立全局状态机或缓存系统，即可生成复杂、动态且“活着”的逻辑响应行为


---

## 🔩 工作原理

FPS-R 利用以帧为索引的逻辑 —— 通常包括叠模运算、节奏拉伸曲线与确定性伪随机方法 —— 在无需内部状态的前提下生成熵值。  
它输出的运动与行为在“无记忆”状态下依然能够演化得可信且自然。
