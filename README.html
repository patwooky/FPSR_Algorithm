<!DOCTYPE html><html><head>
      <title>README</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\patri\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.18\crossnote\dependencies\katex\katex.min.css">
      
      
      <script type="text/javascript" src="file:///c:\Users\patri\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.18\crossnote\dependencies\mermaid\mermaid.min.js" charset="UTF-8"></script>
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="-fps-r-algorithm-frame-persistent-stateless-randomisation">🎲 FPS-R Algorithm: Frame-Persistent Stateless Randomisation </h1>
<h1 id="table-of-contents">Table of Contents </h1>
<ul>
<li><a href="#-fps-r-algorithm-frame-persistent-stateless-randomisation">🎲 FPS-R Algorithm: Frame-Persistent Stateless Randomisation</a></li>
<li><a href="#%EF%B8%8F-a-site-map-of-the-documents">🗺️ A Site Map of the Documents</a>
<ul>
<li><a href="#-readme--manifesto-english">📜 Readme — Manifesto (English)</a></li>
<li><a href="#-readme--%E5%AE%A3%E8%A8%80%E7%90%86%E5%BF%B5%E6%8F%8F%E8%BF%B0-chinese">🈸 Readme — 宣言,理念描述 (Chinese)</a></li>
<li><a href="#-the-mathematics-and-mechanics">📐 The Mathematics and Mechanics</a></li>
<li><a href="#-applications">🍭 Applications</a></li>
<li><a href="#-thoughts--reflections-and-conceptual-notes">🧠 Thoughts — Reflections and Conceptual Notes</a></li>
</ul>
</li>
<li><a href="#-what-is-fps-r">🎲 What is FPS-R?</a>
<ul>
<li><a href="#-introduction">🪞 Introduction</a></li>
</ul>
</li>
<li><a href="#-principles-and-philosophy">🎓 Principles and Philosophy</a>
<ul>
<li><a href="#-guiding-principle">🧭 Guiding Principle</a></li>
<li><a href="#-motion-philosophy">🎭 Motion Philosophy</a></li>
<li><a href="#-structure-and-the-illusion-of-chaos">📐 Structure and the Illusion of Chaos</a></li>
</ul>
</li>
<li><a href="#-a-new-grammar-randomised-move-and-hold">🗣 A New Grammar: "Randomised Move-and-Hold"</a></li>
<li><a href="#-key-features">✨ Key Features</a></li>
<li><a href="#-sample-uses-in-animation">🎞 Sample Uses in Animation</a></li>
<li><a href="#-sample-uses-in-geometry-generation">🧱 Sample Uses in Geometry Generation</a></li>
<li><a href="#-why-do-i-need-another-random-stream-generator">💡 Why Do I Need Another Random Stream Generator?</a>
<ul>
<li><a href="#-the-nature-of-held-randomness">🧬 The Nature of "Held" Randomness</a></li>
<li><a href="#-limitations-of-conventional-techniques">🧱 Limitations of Conventional Techniques</a></li>
<li><a href="#%EF%B8%8F-why-fps-r-is-different">⚙️ Why FPS-R is Different</a></li>
</ul>
</li>
<li><a href="#-flavours-of-fps-r">🧬 Flavours of FPS-R</a>
<ul>
<li><a href="#-stacked-modulo-sm-or-%E5%8F%A0%E6%A8%A1%E6%9C%BA%E5%88%B6">🌀 Stacked Modulo (SM) or 叠模机制</a></li>
<li><a href="#-quantised-switching-qs-or-%E9%87%8F%E8%B7%83%E6%9C%BA%E5%88%B6">✴ Quantised Switching (QS) or 量跃机制</a></li>
</ul>
</li>
<li><a href="#-spatial-extension-from-time-to-space">🏙 Spatial Extension: From Time to Space</a>
<ul>
<li><a href="#-quantised-switching-in-space">✴ Quantised Switching in Space</a></li>
</ul>
</li>
<li><a href="#-recursive-chaos-fps-r-as-modulator">🧠 Recursive Chaos: FPS-R as Modulator</a>
<ul>
<li><a href="#fractal-modulation">Fractal Modulation</a></li>
</ul>
</li>
<li><a href="#-meta-signal-analysis-fps-r-as-its-own-observer">📈 Meta-Signal Analysis: FPS-R as Its Own Observer</a></li>
<li><a href="#-domains-of-application">🧪 Domains of Application</a>
<ul>
<li><a href="#%EF%B8%8F-arvr-and-human-centered-interaction">🕶️ AR/VR and Human-Centered Interaction</a></li>
<li><a href="#-robotics-and-embodied-systems">🤖 Robotics and Embodied Systems</a></li>
<li><a href="#-swarms-drones-and-spatial-coverage-systems">🛰 Swarms, Drones, and Spatial Coverage Systems</a></li>
<li><a href="#-embedded-systems-and-ambient-interfaces">💡 Embedded Systems and Ambient Interfaces</a></li>
<li><a href="#-domains-of-application-in-audio-and-composition">🎼 Domains of Application in Audio and Composition</a></li>
<li><a href="#-cognitive-modeling-and-generative-thought">🧠 Cognitive Modeling and Generative Thought</a></li>
<li><a href="#-closing-thoughts-on-usage">🌐 Closing Thoughts on Usage</a></li>
</ul>
</li>
<li><a href="#-how-fps-r-works-a-gentle-primer">🔩 How FPS-R Works (A Gentle Primer)</a>
<ul>
<li><a href="#-stacked-modulo-sm">🎼 Stacked Modulo (SM)</a></li>
<li><a href="#%EF%B8%8F-quantised-switching-qs">✴️ Quantised Switching (QS)</a></li>
</ul>
</li>
<li><a href="#%EF%B8%8F-tiling-note-seamlessness-in-spatial-fps-r">⚠️ Tiling Note: Seamlessness in Spatial FPS-R</a>
<ul>
<li><a href="#-techniques-for-seam-aware-behavior">🪡 Techniques for Seam-Aware Behavior</a></li>
</ul>
</li>
<li><a href="#-current-status">🚧 Current Status</a></li>
<li><a href="#%EF%B8%8F-additional-development-notes">🗒️ Additional Development Notes</a>
<ul>
<li><a href="#-fpsr-thoughts">🧠 FPSR Thoughts</a></li>
<li><a href="#-development-reflections">📔 Development Reflections</a></li>
</ul>
</li>
<li><a href="#-contributions">🤝 Contributions</a></li>
</ul>
<hr>
<h2 id="️-a-site-map-of-the-documents">🗺️ A Site Map of the Documents </h2>
<div class="Mermaid mermaid">%%{ init: { "theme": "neutral" } }%%
graph TD
  A[README.md 🏁&lt;br&gt;Manifesto &amp; Overview] --&gt; B[FPSR_Tech.md 📐&lt;br&gt;Mathematics &amp; Mechanics]
  A --&gt; C[FPSR_Applications.md 🍭&lt;br&gt;Cross-Domain Use Cases]
  A --&gt; D[README-CH.md 🈸&lt;br&gt;Chinese Manifesto]
  A --&gt; E[Thoughts.md 🧠&lt;br&gt;Reflections &amp; Conceptual Notes]

  classDef fileStyle fill:#C2C2C2,stroke:#333,stroke-width:1px,color:#000,rx:6,ry:6,font-size:14px;
  classDef thoughtHighlight fill:#CFC299,stroke:#444,stroke-width:1.5px,color:#000,rx:6,ry:6,font-size:14px,font-style:italic;

  class A,B,C,D fileStyle
  class E thoughtHighlight
</div><h3 id="-readme--manifesto-english">📜 Readme — Manifesto (English) </h3>
<p><strong>You are here</strong>. This is the primary document. It presents FPS-R as both a motion grammar and a collection of expressive tools, and serves as a lens through which to understand not only how FPS-R functions, but also why it evokes the qualities it does.</p>
<h3 id="申-readme--宣言理念描述-chinese">🈸 Readme — 宣言,理念描述 (Chinese) </h3>
<p><a href="README-CH.md">Click here: 自述文件 — 中文版 (README-CH.md)</a><br>
The Chinese edition of the manifesto, presenting the philosophical and expressive foundation of FPS-R in Mandarin.</p>
<h3 id="-the-mathematics-and-mechanics">📐 The Mathematics and Mechanics </h3>
<p><a href="resources/readme/FPSR_Tech.md">Click here: FPSR_Tech.md</a><br>
This extension document provides the structural foundation beneath the conceptual framing. It outlines the algorithms, expressions, parameters, and architectural elements that support and shape the behaviour of FPS-R.</p>
<h3 id="-applications">🍭 Applications </h3>
<p>This document complements and extends the applications of FPS-R beyond the high-level summarised view provided in this ReadMe file. The document will dig deeper into each domain and provide larger number of use cases for each area of use.<br>
<a href="resources/readme/FPSR_Applications.md">Click here: FPSR_Applications.md</a></p>
<h3 id="-development-journal--the-chronicle">📓 Development Journal — The Chronicle </h3>
<p><a href="resources/readme/FPSR_Dev_Journal.md">Click here: FPSR_Dev_Journal.md</a><br>
A chronological account and living notebook of the research and design process. It records breakthroughs, failures, struggles, and revisions, offering insight into the iterative development that shaped the current implementation of FPS-R.</p>
<h3 id="-thoughts--reflections-and-conceptual-notes">🧠 Thoughts — Reflections and Conceptual Notes </h3>
<p><a href="resources/readme/FPSR_Thoughts.md">Click here: FPSR_Thoughts.md</a><br>
An archive of nonlinear reflections, theoretical digressions, and design meditations that contributed to the philosophical development of FPS-R. This document functions as a conceptual incubator and critical sketchpad, recording my internal struggles and conflicts. It also provides the philosophical and poetic dimensions of FPS-R's evolution—where structure meets sensation, and randomness finds rhythm.</p>
<hr>
<h2 id="-what-is-fps-r">🎲 What is FPS-R? </h2>
<h4><em>Stateless unpredictability with a structured soul.</em> {#<em>stateless-unpredictability-with-a-structured-soul</em> }</h4>
<p><strong>FPS-R</strong> is a system that expresses a motion archetype we call  <strong>"Randomized Move-and-Hold."</strong><br>
Unlike traditional simulations, it sculpts discontinuity with structure—producing behavior that feels instinctual<br>
and organic, yet requires no memory or state.</p>
<p>This concept forms the bedrock of FPS-R's philosophy...</p>
<h3 id="-introduction">🪞 Introduction </h3>
<p><strong>FPS-R</strong> stands for <code>Frame-Persistent Stateless Randomisation</code> (or <code>静态律动算法</code> in Chinese). It is a philosophy behind a collection of lightweight algorithmic pattern for simulating persistent yet stateless randomness across a continuous timeline—ideal for procedural motion, glitch aesthetics, synthesised organic behaviour, and analogue artefact emulation.</p>
<p>Inspired by natural behaviours such as eye saccades, animal foraging, human hesitation, predatory stalking, and structured noise, FPS-R produces unpredictability without relying on memory of the previous-frame. It mirrors the rhythm of an explorer's torch as he explores a darkened cave—pausing, twitching, drifting with intent—or the room-clearing manoeuvre of a soldier's rifle: moving and holding from one strategic point to another, every new holding position disjointed from what came before.</p>
<blockquote>
<p><em><strong>FPS-R is a manipulator of values over time, sculpting values and temporal behavior</strong></em></p>
</blockquote>
<p>When FPS-R is driven by space instead of time, it becomes something else entirely: a sculptor of forms, a builder of skylines. Its jump-hold logic becomes spatial patterning. Its rhythms become relief.</p>
<blockquote>
<p><em><strong>FPS-R is not just a motion language—it is a geometry dialect.</strong></em></p>
</blockquote>
<p>It is <strong>repeatable</strong>, <strong>tunable</strong>, and <strong>frame-specific</strong>, making it a versatile tool for time-based content creation platforms (Houdini, Maya, 3D Studio Max, Nuke, Adobe After Effects), GLSL, P5.js, game engines (Unity, Unreal), and embedded environments. Thanks to its simplicity and efficiency, FPS-R can also be implemented in any 3D platform that supports expressions or scripting.</p>
<p>In the spatial domain, FPS-R can be implemented into shaders for vertex displacement or surface perturbation, with its effects expressed through normals, bumps, and parallax techniques. When integrated with procedural modeling workflows, it becomes a generator of richly detailed and recursively layered geometry—ideal for greebling, erosion maps, stylised terrain, and sci-fi paneling. While the nature of FPS-R is non-repeating, with appropriate use of tiling techniques it allows spatial patterns to tile seamlessly across UVs or wrap naturally around curved surfaces, offering control without constraint.</p>
<hr>
<h3 id="-principles-and-philosophy">🎓 Principles and Philosophy </h3>
<hr>
<h3 id="-guiding-principle">🧭 Guiding Principle </h3>
<p>"FPS-R isn't a single algorithm. It's a design philosophy for <em>shaping signals</em>. Whether by arithmetic folding or signal quantisation — whether in time or space — the goal is the same: give structure permission to behave."</p>
<h3 id="MotionPhil">🎭 Motion Philosophy </h3>
<p><strong>FPS-R simulates the unpredictability of hesitation — yet within the same framework, it can just as easily express instinct.</strong></p>
<ul>
<li>When its temporal holds are short, it expresses <em>impulse</em>: quick changes that feel twitchy, clipped, or alert.</li>
<li>With longer holding durations, it evokes <em>hesitation</em>: thoughtful pauses, lingering states, the illusion of deliberation.</li>
</ul>
<p>It does not switch modes—it sculpts time. The values may be random, but <em>when</em> they appear is guided by the frame count itself—producing a rhythm that feels intentional, even without memory.</p>
<p>What emerges is not chaos, but <em>temporal behaviour shaped by structure</em>.</p>
<blockquote>
<p>🧒 <strong>This rhythm echoes freeze-tag games across cultures</strong> —<br>
<strong>"A-E-I-O-U!"</strong> in Singapore, <strong>"1, 2, 3 Soleil!"</strong> in France, or <strong>"Statues"</strong> in Greece.<br>
<strong>"무궁화 꽃이 피었습니다"</strong> in Korea, <strong>"木头人" in Chinese cultures</strong>,<br>
<strong>"Grandmother's Footsteps"</strong> in the UK, <strong>"Red Light, Green Light"</strong> in the U.S.<br>
Each moment of stillness feels impulsive yet structured —<br>
a hidden choreography of burst and restraint.</p>
</blockquote>
<blockquote>
<p>🧠 <strong>Teaching Note: "No-sim is the best sim."</strong><br>
In teaching Houdini—which is famed for simulation—I often remind students that building a procedural system without frame-to-frame dependencies is often superior to relying on complex simulations.<br>
The most elegant systems allow each frame to stand alone—yet somehow feel like they remember the past.</p>
</blockquote>
<h3 id="-structure-and-the-illusion-of-chaos">📐 Structure and the Illusion of Chaos </h3>
<p>While FPS-R signals appear spontaneous, they are grounded in strictly deterministic logic. Each change is orchestrated through functions like <code>mod()</code>, <code>rand()</code>, and cyclic layering—producing motion that feels unstructured, yet is born from rules.</p>
<p>This is not randomness—it is <em>engineered emergence</em>.</p>
<p>Apparent unpredictability arises from the interaction of overlapping cycles, misaligned reseeds, and frame-local recalculations. No memory is used, yet the system breathes. It hesitates, pulses, switches rhythm—not because it reacts, but because its structures <em>interfere just enough</em> to simulate reaction.</p>
<blockquote>
<p><strong>Chaos is not the engine. It is the performance.</strong><br>
And every performance begins with a script.</p>
</blockquote>
<p>This tension—between definition and drift—is not a flaw. It's the expressive core of FPS-R.</p>
<hr>
<h2 id="-a-new-grammar-randomised-move-and-hold">🗣 A New Grammar: "Randomised Move-and-Hold" </h2>
<p>FPS-R introduces not just a new fet of algorithms, but a new <em>lexicon</em> for motion.<br>
What it produces is not a filter or a curve — but a compositional structure:<br>
<strong>jump → hold → reseed → repeat</strong></p>
<p><em>FPS-R: Behaviour Compositional Structure</em></p>
<div class="mermaid">graph LR
  A[Jump]:::darkBrown --&gt; B[Hold]:::darkYellow 
  B --&gt; C[Reseed]:::darkRed --&gt; D[Repeat]:::red

classDef darkBrown fill:#654321,stroke:#553311,stroke-width:3px,rx:10,ry:10;
classDef darkYellow fill:#B8860B,stroke:#986609,stroke-width:3px,rx:10,ry:10;
classDef darkRed fill:#8B0000,stroke:#5B0000,stroke-width:3px,rx:10,ry:10;
classDef red fill:#FF0000,stroke:#AA0000,stroke-width:3px,rx:10,ry:10;
</div><p>We call this behavior <strong>Randomised Move-and-Hold</strong>.</p>
<p>It captures the quality of twitch, of deliberation, of pauses that feel like thought.</p>
<hr>
<h2 id="-key-features">✨ Key Features </h2>
<ul>
<li>Frame-anchored <strong>repeatability</strong> without storing state</li>
<li>Tunable <strong>chaos profiles</strong> with modular curve sculpting</li>
<li>Compatible with stateless shaders, simulation loops, and real-time systems</li>
<li>Ideal for generating behaviour that feels <strong>alive</strong>, not algorithmic</li>
</ul>
<hr>
<h2 id="-sample-uses-in-animation">🎞 Sample Uses in Animation </h2>
<p><img src="resources/readme/images/h_fpsr_01_v002_02.gif" alt="Single Eyeball Look Straight Ahead with Saccades"><br>
<em>Eye saccades or darting behaviour in Houdini — Single Eyeball Look Straight Ahead with Saccades</em></p>
<p><img src="resources/readme/images/h_fpsr_01_v002.gif" alt="Double Eyeballs Look at a Moving Box with Layered FPS-R Saccades"><br>
<em>Saccades layered on top of object tracking in Houdini — Double Eyeballs Look at a Moving Box with Layered FPS-R Saccades</em></p>
<hr>
<h2 id="-sample-uses-in-geometry-generation">🧱 Sample Uses in Geometry Generation </h2>
<hr>
<h2 id="-why-do-i-need-another-random-stream-generator">💡 Why Do I Need Another Random Stream Generator? </h2>
<h3 id="-the-nature-of-held-randomness">🧬 The Nature of "Held" Randomness </h3>
<p>In both natural and artificial systems, randomness is rarely pure noise—it often lingers, persists, or evolves in a way that feels intentional. Whether it's the shimmer of dappled light, the jitter of analogue machinery, or the twitchy searching of eye saccades, we encounter random behaviours that hold their shape or drift over time. Yet despite how ubiquitous this phenomenon is, most content creation tools are ill-equipped to simulate, emulate and represent it in an intuitively straightforward and lightweight manner. Replicating this structured unpredictability often requires labour-intensive custom coding or non-intuitive workarounds.</p>
<blockquote>
<p>✒️ Metaphor Note: <em>The FPS-R system is like a public pen at the post office.</em><br>
People come and go: one picks it up, another leaves it askew, sometimes no one touches it for hours.<br>
Each interaction changes its orientation, position, or status—but never with memory.<br>
Yet from a time-lapse sped-up video review, it appears to dance with intention.</p>
</blockquote>
<br>
<p align="center">
  <img src="https://img.shields.io/badge/algorithmic-chaos%20with%20poise-blueviolet?style=flat-square" alt="Algorithmic Chaos with Poise">
  <img src="https://img.shields.io/badge/stateless-beauty-lightgrey?style=flat-square" alt="Stateless Beauty">
  <img src="https://img.shields.io/badge/memoryless-not%20mindless-9cf?style=flat-square" alt="Memoryless, Not Mindless">
</p>
<h3 id="-limitations-of-conventional-techniques">🧱 Limitations of Conventional Techniques </h3>
<p>The most common approaches tend to fall into two camps:</p>
<ul>
<li>
<p><strong>Worley-like noise functions</strong>: These typically rely on spatially seeded feature points—often distributed via jittered grids or hash-based schemes—and compute distances between each sample and its surrounding points.<br>
While powerful for generating cellular textures, standard Worley noise tends to use evenly spaced seed distributions, leading to Voronoi-like cells with relatively uniform size and brightness. This results in predictable distance falloffs and similar displacement amplitudes across the field, which limits its expressiveness in simulating more erratic or organic behaviours.<br>
Additionally, it requires multiple computation steps—lookup tables, distance evaluations, sorting—which can be costly, especially when combining higher-order Fn layers, applying input warping, or layering across octaves.<br>
These techniques increase complexity and make Worley noise more difficult to visualise or intuitively control compared to simpler stateless methods.</p>
</li>
<li>
<p><strong>Previous-frame dependent logic</strong>: This method can emulate "held" randomness by passing state from frame to frame. However, it introduces complexity and tightly couples your logic to platforms that support such state sharing (e.g., Houdini). Furthermore, it often cannot be implemented in lightweight contexts like expression fields or shader snippets, limiting its portability.</p>
</li>
</ul>
<h3 id="️-why-fps-r-is-different">⚙️ Why FPS-R is Different </h3>
<p>FPS-R introduces a lightweight and highly portable solution to this long-standing problem. At its core is the <strong>Stacked Modulo (SM)</strong> method, which generates structured, frame-evolving randomness without relying on state or lookup tables.</p>
<p>Key advantages include:</p>
<ul>
<li>✅ <strong>Truly Stateless</strong>: FPS-R does not rely on previous-frame data or persistent memory buffers</li>
<li><strong>🔒 Fully Deterministic</strong>: With the same inputs, FPS-R always produces the same outputs—no entropy, no surprises</li>
<li>🧠 <strong>Compact &amp; Readable</strong>: The SM expression can be written in a single line using <code>$F</code> in Houdini expressions or <code>@Frame</code> in VEX</li>
<li>🛠️ <strong>Platform Agnostic</strong>: Works seamlessly in any environment that exposes frame-based context</li>
<li>⚡ <strong>Performance Friendly</strong>: No costly distance functions, hash lookups, or scatter generation</li>
</ul>
<blockquote>
<h4 id="-memoryless-mimicry">🪞 Memoryless Mimicry </h4>
<p>A simulation remembers so it can anticipate. FPS-R forgets, but still manages to feel like it remembers.</p>
</blockquote>
<blockquote>
<h4 id="-deterministic-complexity">🧩 Deterministic Complexity </h4>
<p>Where intricate behavior emerges from repeatable rules, not randomness.</p>
</blockquote>
<hr>
<h2 id="-why-not-just-use-state">❓ Why Not Just Use State? </h2>
<p>In a <strong>stateful</strong> system, behavior depends on remembering what happened before—like a dancer who needs to recall their last step before taking the next. A <strong>stateless</strong> system, like FPS-R, creates movement from the moment itself—each decision shaped by context, not memory.</p>
<p>Before FPS-R, developers often implemented behavior modulation using <strong>ad hoc stateful logic</strong>—tracking frame counters, timers, or conditional gates to "hold" a value or trigger a change. You’ve probably coded this already: hold a value, flip a coin to jump, repeat. It works. These methods are effective in simple contexts. But they are rooted in state, scaffolding, and context-specific logic. They fragment. They proliferate. And most importantly—they don’t scale across time, space, and systems.</p>
<p><strong>So why does FPS-R exist?</strong><br>
FPS-R doesn’t replace stateful methods—it transcends it.</p>
<p>Because beyond simple systems lies a world of <strong>stateless surfaces</strong>, <strong>reproducible timelines</strong>, and <strong>modular behaviors</strong> that demand more than scattered logic and local memory. That’s where traditional state falters—and where FPS-R begins.</p>
<p><strong>Why Traditional State Falls Short</strong><br>
<strong>🧳 State Doesn’t Travel</strong> Your hold/reseed-jump loop works in a script—but it relies on persistent memory. That loop breaks in shaders, in stateless expression fields, in stream processors, GPU pipelines—anywhere <strong>state doesn’t persist</strong>. FPS-R? Stateless by design. It runs wherever functions do: in time, in space, in parallel.</p>
<p><strong>🧠 No Forensic Trail</strong> Once a stateful loop has run, its past is a blur of overwritten variables. A crash at frame 58200? Good luck explaining why your held value jumped. FPS-R is deterministic and leaves a procedural trail: any frame, any capsule, always reproducible. Every decision path is reconstructable from a seed and a frame. FPS-R a glass box—not just a tool, but a timeline.</p>
<p><strong>🌌 Time-Bound, Not Domain-Agnostic</strong> Stateful loops are temporal by nature. They work on a clock. Try to modulate a surface, a gesture velocity, or a gaze field—<strong>time-only logic fractures</strong>. FPS-R works across <strong>domain inputs</strong>. Any scalar, vector, or multidimensional stream can become a behavior substrate.</p>
<p><strong>🧭 Hard to Compose</strong> Integrating multiple stateful modulators is brittle. FPS-R capsules are modular, chainable, and named. They compose cleanly—stackable, layerable, with expressive guarantees. With input parameters, you describe intent—hesitate, glide, surprise—and the capsule knows how to phrase it.</p>
<p><strong>💡 The Real Difference</strong><br>
FPS-R doesn’t scaffold behavior through memory or timers—it composes it directly, using deterministic randomness and stateless modulation. With reproducibility by design and support for spatial and temporal domains, it acts not just as a method but as a grammar: one that encodes drift, hesitation, and surprise across surfaces, systems, and synthetic agents.</p>
<blockquote>
<p>Traditional state holds behavior in place. <strong>FPS-R lets behavior move—across systems, across domains, across minds.</strong></p>
</blockquote>
<hr>
<h2 id="-flavours-of-fps-r">🧬 Flavours of FPS-R </h2>
<h3 id="-stacked-modulo-sm-or-叠模机制">🌀 Stacked Modulo (SM) or 叠模机制 </h3>
<p>The original FPS-R method. Uses layered modulus operations and shifting offsets to produce coherent but unpredictable transitions.</p>
<ul>
<li>Feels like <em>memory without memory</em></li>
<li>Shaped by frequency, amplitude, and phase</li>
<li>Lightweight and highly composable</li>
</ul>
<p><strong>SM Features:</strong></p>
<ul>
<li>Adjustable upper bounds for how long values are held</li>
<li>Adjustable lower bounds to influence the minimum possible hold duration between jumps.</li>
<li>Uses <code>rand()</code> and <code>mod()</code> functions on current frame</li>
<li>Works in one-liner form in many toolkits</li>
</ul>
<hr>
<h3 id="-quantised-switching-qs-or-量跃机制">✴ Quantised Switching (QS) or 量跃机制 </h3>
<p>A deterministic pseudo-random index selector for flickering, logic switching, and glitch-like transitions.</p>
<p><strong>QS Features:</strong></p>
<ul>
<li>Supports custom value banks</li>
<li>Can bypass randomness for structured switching</li>
<li>Quantisation optional for smooth interpolation</li>
</ul>
<hr>
<h2 id="-spatial-extension-from-time-to-space">🏙 Spatial Extension: From Time to Space </h2>
<p><strong>FPS-R doesn't just animate. It extrudes. It embosses. It <em>grows surfaces</em>.</strong></p>
<p>By replacing time (<code>$F</code>, <code>@Frame</code>, etc.) with space (<code>x</code>, <code>y</code>, <code>uv</code>, or <code>position</code>), FPS-R becomes a <strong>procedural modeling toolkit</strong>—ideal for generating blocky silhouettes, architectural detail, and sci-fi surface features.</p>
<h3 id="spatial-modes">Spatial Modes </h3>
<ul>
<li>
<p><strong>1D → 2D Profiles</strong><br>
Use a 1D FPS-R output along the <code>x</code>-axis:</p>
<ul>
<li>Random <em>jump-hold</em> patterns mimic building silhouettes</li>
<li>Perfect for stylised skylines, barcode patterns, or abstract bas-reliefs</li>
</ul>
</li>
<li>
<p><strong>2D → 3D Extrusions</strong><br>
Feed FPS-R(x, y) into a heightfield or mesh extrusion driver:</p>
<ul>
<li>Generates grid-based paneling, mechanical greebles, and terrain</li>
<li>Works seamlessly with subdivide/bevel workflows</li>
</ul>
</li>
<li>
<p><strong>Curved Surfaces and Wrapping</strong><br>
Since FPS-R is stateless, spatial lookups can wrap around UV shells or cylindrical coordinates without visual seams</p>
<ul>
<li>Enables pattern generation across spherical helmets, pipes, or organic topologies</li>
</ul>
</li>
</ul>
<br>
<p align="center">
  <img src="https://img.shields.io/badge/🏗_Procedural_Form-green?style=flat-square" alt="Procedural Form">
  <img src="https://img.shields.io/badge/🔢_Signal_as_Structure-blue?style=flat-square" alt="Signal-as-Structure">
</p>
<h3 id="-quantised-switching-in-space">✴ Quantised Switching in Space </h3>
<p>QS becomes a <strong>signal switcher</strong> in the spatial domain:</p>
<ul>
<li>Swap randomisation engines (Perlin, Worley, texture samplers)</li>
<li>Turn off quantisation for fluid transitions</li>
<li>Amplify for brutalist modularity or broken repetition</li>
</ul>
<blockquote>
<p>"Just as QS modulates time by switching behavioural regimes, it can modulate space by switching surface logic—turning texture banks or heightmap engines on and off with structured unpredictability."</p>
</blockquote>
<hr>
<h2 id="-recursive-chaos-fps-r-as-modulator">🧠 Recursive Chaos: FPS-R as Modulator </h2>
<p>FPS-R can <strong>modulate itself</strong>, creating layered complexity with no external drivers.</p>
<h3 id="fractal-modulation">Fractal Modulation </h3>
<ul>
<li>
<p>Use one FPS-R stream as a <strong>mask</strong> to blend or gate other FPS-R-driven elements</p>
<ul>
<li>Example: A coarse FPS-R field dictates <em>where</em> a finer FPS-R field is active</li>
<li>Creates nested, self-similar regions with varied character</li>
</ul>
</li>
<li>
<p>Enables <strong>multi-scale detailing</strong> without visible repetition</p>
<ul>
<li>Large jumps define macro structure</li>
<li>Inner layers fill those zones with micro-patterns</li>
</ul>
</li>
</ul>
<blockquote>
<p>🪨 Like natural erosion: cliffs shaped by tectonics, then chipped by rain</p>
</blockquote>
<p>This approach keeps procedural output feeling coherent but rich—and helps avoid the flatness of a single noise function. The result is a <em>generative grammar</em>, not just a random script.</p>
<p align="center">
  <img src="https://img.shields.io/badge/📦_Fractal_Assembly-purple?style=flat-square" alt="Fractal Assembly">
</p>
<hr>
<h2 id="-meta-signal-analysis-fps-r-as-its-own-observer">📈 Meta-Signal Analysis: FPS-R as Its Own Observer </h2>
<p>While FPS-R was born as a generator of structured unpredictability, its signal output can be <strong>reprojected into geometry</strong>—turning behaviour over time into readable <em>form</em>. By mapping its jump-hold patterns into 2D or 3D space, we can analyse:</p>
<ul>
<li><strong>Behavioural rhythms</strong> as architectural silhouettes</li>
<li><strong>Decision states</strong> as temporal glyphs or waveform landscapes</li>
<li><strong>Modulation layers</strong> as recursive embedded zones</li>
</ul>
<p>This enables FPS-R to serve as both <em>performer</em> and <em>diagnostician</em>: a self-scribing signal whose own visualisations can uncover insight into its frequency, persistence, and switch thresholds.</p>
<blockquote>
<p>Imagine plotting each state-switch as a block on a time axis—producing a skyline of decisions. Or warping that same skyline into spatial slices—creating a textured audit trail of signal intent.</p>
</blockquote>
<p>Such representations can be useful for:</p>
<ul>
<li>Teaching and debugging FPS-R behaviour</li>
<li>Designing visual encodings of abstract logic</li>
<li>Using geometry as feedback for <strong>temporal tuning</strong></li>
</ul>
<p>Ultimately, this reframes FPS-R as more than procedural fodder—it becomes a <strong>conceptual instrument</strong>, capable of looking back at itself through form.</p>
<hr>
<h2 id="-domains-of-application">🧪 Domains of Application </h2>
<p>FPS-R operates as an expressive layer within systems where <strong>intent selection</strong> (planning, decision-making, inference) is decoupled from <strong>behavioral execution</strong> (movement, modulation, feedback). In these architectures, macro-level goals define what should happen, while FPS-R shapes how it happens—animating motion, timing, or modulation with organic nuance.</p>
<p>Across domains—from robotics to haptics, vision to audio, biofeedback to cognitive systems—FPS-R introduces <strong>deterministic unpredictability</strong>, enabling systems to behave with <strong>structured spontaneity</strong> and <strong>non-repeating richness</strong>, even under stateless constraint.</p>
<p>Though the capsules documented here illustrate practical integrations, they reflect only a fraction of FPS-R's expressive spectrum. Wherever systems move, gesture, signal, or <strong>respond—not by chance, but with intention</strong>—FPS-R can encode texture, delay, emphasis, or drift, grounding synthetic behavior in a rhythm that feels quietly alive.</p>
<blockquote>
<p>Whether shaping drift in a robotic limb, phrasing a haptic pulse, or pacing the gaze of an attention agent, FPS-R offers a grammar for micro-behavior—adaptable across systems, expressive without memory, and resonant with human timing.</p>
</blockquote>
<h3 id="️-arvr-and-human-centered-interaction">🕶️ AR/VR and Human-Centered Interaction </h3>
<p>Enhance gaze realism, avatar subtlety, and user modeling through structured micro-variation. FPS-R simulates organic attention and perceptual drift—ideal for believable interaction, accessibility testing, and immersive behavioral nuance.</p>
<h3 id="-robotics-and-embodied-systems">🤖 Robotics and Embodied Systems </h3>
<p>Infuse robots with micro-behavior that signals awareness, hesitation, or subtle intent. FPS-R drives expressive motion and non-repeating attention patterns—ideal for idle simulation, adaptive control, and believable human-robot interaction.</p>
<h3 id="-wearables-and-assistive-technologies">🧤 Wearables and Assistive Technologies </h3>
<p>FPS-R restores expressive nuance to prosthetics, exosuits, and haptic wearables—introducing natural micro-variation that makes robotic extensions feel embodied, familiar, and socially intuitive. It enhances psychological acceptance for users, eases interaction for others, and reintroduces dignity through movement that feels quietly human.</p>
<h3 id="-biofeedback-and-adaptive-expression">🧬 Biofeedback and Adaptive Expression </h3>
<p>FPS-R gives biofeedback systems a voice—translating internal signals into rhythmic, non-repeating feedback that guides, calms, and attunes. It renders physiological data with expressive timing, helping users feel seen, supported, and subtly understood.</p>
<h3 id="-swarms-drones-and-spatial-coverage-systems">🛰 Swarms, Drones, and Spatial Coverage Systems </h3>
<p>By modulating micro-deviations, route pauses, and procedural hesitation, FPS-R allows drones and mobile agents to avoid repetitive patterns while maintaining deterministic replayability. It enables expressive decentralization—no memory, no communication overhead, just lifelike modulation at the edge.</p>
<h3 id="-embedded-systems-and-ambient-interfaces">💡 Embedded Systems and Ambient Interfaces </h3>
<p>Whether it's a kinetic sculpture, an expressive animatronic, or a wearable signaling device, FPS-R enables stateless behavior that feels alive and intentional. Drift, hold, and repeat parameters can be tuned precisely—even in microcontroller environments with limited cycles.</p>
<h3 id="-domains-of-application-in-audio-and-composition">🎼 Domains of Application in Audio and Composition </h3>
<p>🎼 Audio Systems and Musical Modulation<br>
FPS-R brings <strong>rhythmic awareness</strong> to generative music, instrument expression, and sound design—aligning modulation with beats, bars, and phrase timing. From glitch textures to analogue warmth, <strong>it enables sonic systems to groove, drift, and phrase with intention</strong>.</p>
<h3 id="️-game-theory-politics-and-strategic-modeling">⚔️ Game Theory, Politics, and Strategic Modeling </h3>
<p>Model decision rhythms, timing asymmetries, and state transitions across agents and adversaries. FPS-R brings temporal nuance to strategic simulations—mapping escalation, delay, and unpredictability with deterministic control.</p>
<h3 id="️-cybersecurity-and-adversarial-simulation">🛡️ Cybersecurity and Adversarial Simulation </h3>
<p>Generate procedural threats that are stateless, layered, and perfectly replayable. FPS-R enables red/blue parity, forensic breach capsule logging, and scenario-driven defense training under controlled chaos.</p>
<h3 id="-financial-systems-and-economic-simulation">💸 Financial Systems and Economic Simulation </h3>
<p>Model structured volatility and regime shifts with deterministic unpredictability. FPS-R enables stress testing of trading algorithms, policy resilience, and systemic stability—without relying on historical data.</p>
<h3 id="-software-testing-and-fuzzing">🧪 Software Testing and Fuzzing </h3>
<p>Simulate unpredictable user and API behavior with structured randomness. FPS-R can expose fragile edge cases and systemic blind spots—offering deterministic chaos for input fuzzing, timing violation, and error cascade discovery.</p>
<h3 id="-systems-level-protocol--infrastructure-simulation">🧵 Systems-Level Protocol &amp; Infrastructure Simulation </h3>
<p>Simulate layered protocol behavior and infrastructure churn using deterministic modulation. Reconstruct systemic failures, timing anomalies, and resilience under pressure.</p>
<h3 id="-process--contingency-simulation">🧭 Process &amp; Contingency Simulation </h3>
<p>Model operational drift, failure cascades, and procedural stress scenarios with structured randomness. Ideal for testing resilience in planning, logistics, and industrial workflows.</p>
<h3 id="-cognitive-modeling-and-generative-thought">🧠 Cognitive Modeling and Generative Thought </h3>
<p>FPS-R extends beyond expressive motion into <strong>synthetic cognition</strong>, where it serves as a catalyst for emergent reasoning and idea synthesis. This represents the apex of its conceptual reach—where simulation becomes origination.</p>
<ul>
<li>
<p><strong>Thought Flow Modulation in LLMs</strong><br>
Functions as a temporal pacing engine. FPS-R modulates attention across tokens, simulating deliberation (hold), exploration (jump), and drift—producing responses with nuanced cognitive rhythm.</p>
</li>
<li>
<p><strong>Fuzzy Logic Adaptation</strong><br>
Continuously modulates inference thresholds and rule boundaries to reflect evolving ambiguity or multi-modal conditions—without requiring persistent state or retraining.</p>
</li>
<li>
<p><strong>Procedural Dialogue and Conversational Tangents</strong><br>
Shapes conversational rhythm and thematic fluidity in synthetic agents. FPS-R enables natural topic retention, intentional pivots, and pacing realism.</p>
</li>
<li>
<p><strong>Conceptual Trajectory Sampling: FPS-R as Path and Behavior</strong><br>
When FPS-R initiates a transition between semantic regions (start_vector to end_vector), it defines a trajectory—an active signal stream rather than a static interpolation. This trajectory itself can be structured by FPS-R, exhibiting jump-hold dynamics along its arc. At each sampled waypoint, related tokens are drawn not only from proximity but through <strong>layered randomness</strong>, allowing bursts of associative insight or tangential grabs that echo creative intuition.</p>
<p>The result is a synthesized idea that is not merely a blend of endpoints, but a <strong>path-dependent composition</strong>—one where the journey shapes the destination, and stochastic sampling enriches conceptual texture. This moves beyond simulating the appearance of cognition and into the territory of <strong>generating synthetic thought</strong> with structured expressive motion.</p>
</li>
</ul>
<h3 id="-closing-thoughts-on-usage">🌐 Closing Thoughts on Usage </h3>
<p>The examples above trace a constellation, not a boundary. As FPS-R pulses into prosthetics, haptic grammars, biofeedback loops, vision rhythms, and musical phrasing, its grammar still remains unfinished.</p>
<p>It doesn't simulate intelligence—it expresses modulation. Not a model of thought, but a choreography of response.</p>
<p>Whether nested in a footstep, a glance, a circuit, or a breath, FPS-R speaks where behavior meets texture—and every new context awaits translation.</p>
<p>So take it. Reshape it. Let it hesitate where no behavior has paused before.</p>
<p>🚀 <em>To modulate boldly, where no signal has modulated before.</em></p>
<hr>
<h2 id="-how-fps-r-works-a-gentle-primer">🔩 How FPS-R Works (A Gentle Primer) </h2>
<p>At its heart, FPS-R is a rhythm machine—generating unpredictable but <em>structured</em> signals over time or space.<br>
It doesn't store memory. It doesn't know what came before.<br>
Yet what emerges feels like hesitation, twitch, or drift.</p>
<p>You tell FPS-R which frame (or position) it's in, and it sculpts a value based on simple math:<br>
modular rhythms, seeded randomness, layered transitions.<br>
From that alone, it creates the illusion of thought—without ever thinking.</p>
<p>FPS-R unfolds through two intertwined methods.<br>
Each one offers a unique lens—structured pulses that unlock different facets of unpredictability.</p>
<p>Here's the basic idea:</p>
<h3 id="-stacked-modulo-sm">🎼 Stacked Modulo (SM) </h3>
<p>Like overlapping metronomes—each frame lands within multiple rhythm layers, each with its own time signature.<br>
Some tick slowly, some twitch fast. Where their cycles overlap, a value is held… until one metronome hits the end of its measure—and triggers a jump.</p>
<p>When does the signal hold?</p>
<ul>
<li>The current frame lands within a stable rhythm layer intersection.</li>
<li>None of the modulo layers reach the end of their cycle.</li>
</ul>
<p>When does the signal jump?</p>
<ul>
<li>One or more rhythm layers complete a cycle (reach "end of measure").</li>
<li>The modular alignment causes a break in value continuity.</li>
<li>A new composite rhythm is formed, triggering the next held value.</li>
</ul>
<h3 id="️-quantised-switching-qs">✴️ Quantised Switching (QS) </h3>
<p>In its most basic form, Quantised Switching is a signal selector. Two signals (typically sine waves) are generated—each with its own time signature, much like SM's layered rhythms.<br>
But instead of flowing smoothly, each signal is sliced into discrete steps. Another rhythm governs the selector itself.<br>
When the selector reaches the end of its measure, a jump occurs—triggering a <em>probable</em> switch to the alternate signal (though it may stay).<br>
Separately, if the currently selected signal jumps between steps, a jump in the final value also happens.</p>
<p>When does the signal hold?</p>
<ul>
<li>The stepped value from the selected signal remains unchanged.</li>
<li>The selector rhythm is still mid-cycle (not yet at the end of a measure).</li>
</ul>
<p>When does the signal jump?</p>
<ul>
<li>The selector rhythm completes its measure → probabilistic switch occurs.</li>
<li>The stepped value of the selected signal changes between frames.</li>
<li>Either event causes a discrete jump in output—without memory of prior state.</li>
</ul>
<p>These layered, deterministic jumps—both in selection and value—offer stylistic glitch, rhythmic flicker, and behavioral unpredictability.</p>
<p>Each method is stateless. Each moment is decided without memory.<br>
And yet, the result feels strangely alive.</p>
<p>👉 <em>Want to unpack the full mechanism, token by token? Dive into the technical breakdown here:</em><br>
<strong><a href="resources/readme/FPSR_Tech.md">Read FPSR_Tech.md →</a></strong></p>
<hr>
<h2 id="️-tiling-note-seamlessness-in-spatial-fps-r">⚠️ Tiling Note: Seamlessness in Spatial FPS-R </h2>
<p>By default, FPS-R generates <em>non-repeating, stateless randomness</em>, which means it does <strong>not</strong> seamlessly tile across UV space or fixed spatial domains out of the box. This unpredictability is part of its power—but for workflows requiring smooth tiling or seamless textures (e.g. UDIM-based materials, game-ready UV atlases), FPS-R can be gently adapted to behave.</p>
<h3 id="-techniques-for-seam-aware-behavior">🪡 Techniques for Seam-Aware Behavior </h3>
<p>Here are strategies to coax FPS-R into cooperating across tile boundaries:</p>
<ul>
<li>
<p><strong>Modulus-Based Tiling</strong><br>
Wrap UVs explicitly using <code>mod(uv, tileSize)</code>. This forces periodicity while keeping the jump-hold quality within each tile.</p>
</li>
<li>
<p><strong>Mirrored Wrapping</strong><br>
Use a reflected modulus: <code>abs(mod(uv, 2.0) - 1.0)</code> for soft continuity at edges—great for symmetric patterns or organic wrapping.</p>
</li>
<li>
<p><strong>Quantised Phase Locking</strong><br>
Divide UV space into quantised cells and derive a consistent <code>rand()</code> seed per cell. This syncs pattern phases across borders.</p>
</li>
<li>
<p><strong>Edge Crossfade (Mask Blending)</strong><br>
Blend FPS-R lookups with slight UV offsets near seam edges. Use <code>smoothstep()</code> masks to interpolate between directions.</p>
</li>
<li>
<p><strong>Layered Distraction</strong><br>
Accept tiling at a coarse base layer, then modulate with finer FPS-R overlays. Even if the base repeats, the compound result feels rich and unresolved.</p>
</li>
</ul>
<blockquote>
<p>🧵 Seamlessness is not default—but it is <em>composable</em>. By embracing layering, offset masking, and structured quantisation, FPS-R can be shaped into tileable, patch-based, or wrapped surface logic without losing its essence.</p>
</blockquote>
<hr>
<h2 id="-current-status">🚧 Current Status </h2>
<p>FPS-R is under active development and currently private during cleanup. Planned improvements:</p>
<ul>
<li>Modular utilities</li>
<li>Plug-and-play GLSL and Houdini expressions</li>
<li>Ready-made presets and chaos profiles</li>
</ul>
<hr>
<h2 id="️-additional-development-notes">🗒️ Additional Development Notes </h2>
<h3 id="-fpsr-thoughts">🧠 FPSR Thoughts </h3>
<p><a href="resources%5Creadme%5Cfpsr_thoughts.md">(click here)</a><br>
This is a the thoughts about the tools I have created.</p>
<h3 id="-development-reflections">📔 Development Reflections </h3>
<p><a href="resources%5Creadme%5Cdevelopment_reflections.md">(click here)</a><br>
This is the chronological diary of the events leading to the discovery of these methods and techniques.</p>
<hr>
<h2 id="-contributions">🤝 Contributions </h2>
<p>If you're into procedural chaos, analogue aesthetics, or the poetry of entropy—your thoughts are welcome once it returns to public life.</p>

      </div>
      
      
    
    
    <script type="module">
// TODO: If ZenUML gets integrated into mermaid in the future,
//      we can remove the following lines.


var MERMAID_CONFIG = ({"startOnLoad":false});
if (typeof MERMAID_CONFIG !== 'undefined') {
  MERMAID_CONFIG.startOnLoad = false
  MERMAID_CONFIG.cloneCssStyles = false
  MERMAID_CONFIG.theme = "default"
}

mermaid.initialize(MERMAID_CONFIG || {})
if (typeof(window['Reveal']) !== 'undefined') {
  function mermaidRevealHelper(event) {
    var currentSlide = event.currentSlide
    var diagrams = currentSlide.querySelectorAll('.mermaid')
    for (var i = 0; i < diagrams.length; i++) {
      var diagram = diagrams[i]
      if (!diagram.hasAttribute('data-processed')) {
        mermaid.init(null, diagram, ()=> {
          Reveal.slide(event.indexh, event.indexv)
        })
      }
    }
  }
  Reveal.addEventListener('slidetransitionend', mermaidRevealHelper)
  Reveal.addEventListener('ready', mermaidRevealHelper)
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
} else {
  await mermaid.run({
    nodes: document.querySelectorAll('.mermaid')
  })
}
</script>
    
    
    
  
    </body></html>